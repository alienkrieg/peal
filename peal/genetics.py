from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum, auto
from typing import Any, Callable, Optional, Union, get_type_hints

import numpy as np


class GeneType(Enum):
    """Enum class for a category of a gene type.
    Availalbe types are:

        * ``NOMINAL``
        * ``ORDINAL``
        * ``METRIC``
        * ``CONST_SIZE``

    This way, non-comparable types in Python are forbidden.
    """

    NOMINAL = auto()
    ORDINAL = auto()
    METRIC = auto()


class GenePool(ABC):
    """Base class for any gene pool in PEAL. A gene pool is a collection
    of alleles for genes an individual can have. With this information,
    a gene pool knows all possible genomes individuals in a population
    for a given problem can have.

    Args:
        typing (GeneType): The typing signature for this gene pool.
        length (int, optional): The length of one genome or ``0`` for
            variable length. Defaults to 0.
    """

    def __init__(self, typing: GeneType, length: int = 0):
        self._size = 0 if typing != GeneType.METRIC else np.inf
        self._typing = typing
        self._initializer: Optional[Callable[[], np.ndarray]] = None
        self._length = length

    @property
    def typing(self) -> GeneType:
        """The typing information of this gene pool."""
        return self._typing

    @property
    def size(self) -> Union[int, float]:
        """The number of different alleles in this gene pool. This might
        also be ``numpy.inf`` for metric scales.
        """
        return self._size

    @property
    def length(self) -> int:
        """The number of genes in one genome generated by this pool.
        If the size of one genome has variable length, this property is
        ``0``.
        """
        return self._length

    @abstractmethod
    def _initialize(self, **kwargs) -> np.ndarray:
        ...

    def create_genome(self, **kwargs) -> np.ndarray:
        """Generates a genome for an individual. The method used to pick
        a random genome can be customized.

        Returns:
            np.ndarray: An array consisting of genes.
        """
        if self._initializer is not None:
            return self._initializer(**kwargs)
        return self._initialize(**kwargs)


class IntegerPool(GenePool):
    """A gene pool of constant length genomes only containing integers
    in the given range.

    Args:
        length (int): The number of genes in a genome.
        lower (int): The smallest integer one gene can be.
        upper (int): The largest integer one gene can be.
    """

    def __init__(
        self,
        length: int,
        lower: int,
        upper: int,
    ):
        super().__init__(typing=GeneType.ORDINAL, length=length)
        self.lower = lower
        self.upper = upper
        self._size = upper - lower + 1

    def _initialize(self, **kwargs) -> np.ndarray:
        return np.random.randint(
            self.lower,
            self.upper + 1,
            size=self.length
        )


class NumberPool(GenePool):
    """A gene pool that supports all floats and integers in a specified
    range.

    Args:
        length (int): The number of genes in a genome.
        lower (int | float): The lower bound for all genes.
        upper (int | float): The upper bound for all genes.
    """

    def __init__(
        self,
        length: int,
        lower: Union[int, float],
        upper: Union[int, float],
    ):
        super().__init__(typing=GeneType.METRIC, length=length)
        self.lower = lower
        self.upper = upper

    def _initialize(self, **kwargs) -> np.ndarray:
        return (
            (self.upper - self.lower)
            * np.random.random_sample(size=self.length)
            + self.lower
        )


class GPNode:
    """Class representation of a node in a genetic programming tree."""

    __slots__ = ("rtype", "name")

    def __init__(self, rtype: type, name: str):
        self.rtype = rtype
        self.name = name


class GPCallable(GPNode):
    """Special GP tree node that represents a elementary function in
    such a tree with multiple arguments and a specific return type.
    """

    __slots__ = ("rtype", "name", "argtypes", "method")

    def __init__(
        self,
        rtype: type,
        name: str,
        argtypes: dict[str, Any],
        method: Callable[..., Any],
    ) -> None:
        super().__init__(rtype, name)
        self.argtypes = argtypes
        self.method = method

    def __call__(self, *args) -> Any:
        return self.method(*args)

    def __repr__(self) -> str:
        return f"{self.name}()"


class GPTerminal(GPNode):
    """Special GP tree node that represents a elementary function in
    such a tree with multiple arguments and a specific return type.
    """

    __slots__ = ("rtype", "name", "value")

    def __init__(
        self,
        rtype: type,
        name: str,
        value: Optional[Any] = None,
    ) -> None:
        super().__init__(rtype, name)
        self.value = value

    @property
    def allocated(self) -> bool:
        return self.value is not None

    def __repr__(self) -> str:
        if not self.allocated:
            return f"<{self.name}>"
        return f"{self.value}"


class GPPool(GenePool):
    """A gene pool that is used for genetic programming. An individual
    in GP has a tree-like structure of genes and single nodes in this
    tree are methods listed in this type of pool.
    New methods should be added by using the decorator
    :meth:`GPPool.allele` on a newly created instance of this class.

    Args:
        min_depth (int): The minimum depth of a genome tree.
        max_depth (int): The maximum depth of a genome tree.
    """

    def __init__(
        self,
        min_depth: int,
        max_depth: int,
    ):
        super().__init__(typing=GeneType.NOMINAL)
        self._elementary: dict[type, list[GPCallable]] = {}
        self._terminal: dict[type, list[GPTerminal]] = {}
        self._min_depth = min_depth
        self._max_depth = max_depth

    @property
    def min_depth(self) -> int:
        return self._min_depth

    @property
    def max_depth(self) -> int:
        return self._max_depth

    def _initialize(self, **kwargs) -> np.ndarray:
        rtype = kwargs.get(
            "rtype",
            np.random.choice(np.array(list(self._elementary.keys()))),
        )
        height = kwargs.get(
            "height",
            np.random.randint(self._min_depth, self._max_depth),
        )
        stack: list[tuple[int, type]] = [(0, rtype)]
        genes = []
        while len(stack) > 0:
            depth, rtype = stack.pop(0)
            if depth == height:
                if rtype not in self._terminal:
                    raise IndexError("Failed to create a GP-based genome; "
                                     f"A terminal allele of type {rtype} "
                                     "is requested but not found.")
                terminal = np.random.choice(np.array(self._terminal[rtype]))
                genes.append(terminal)
            else:
                if rtype not in self._elementary:
                    raise IndexError("Failed to create a GP-based genom; "
                                     f"An elementary allele of type {rtype} "
                                     "is requested but not found.")
                elementary: GPCallable = np.random.choice(
                    np.array(self._elementary[rtype])
                )
                requested_types = elementary.argtypes
                genes.append(elementary)
                for vartype in requested_types.values():
                    stack.append((depth + 1, vartype))
        return np.array(genes)

    def allele(self, func: Callable[..., Any]) -> Callable[..., Any]:
        """Decorator that can be used on a function to add a callable
        as an allele to the pool.
        """
        hints = get_type_hints(func).copy()
        rtype = hints.pop("return")

        if rtype not in self._elementary:
            self._elementary[rtype] = []
        self._elementary[rtype].append(GPCallable(
            rtype=rtype,
            name=func.__name__,
            argtypes=hints,
            method=func,
        ))
        return func

    def add_arguments(self, arguments: dict[str, type]) -> None:
        """Add special terminal symbols, i.e. arguments, to the list of
        alleles in this pool.
        These terminal symbols do not have a fixed value but can be seen
        as arguments that have to be supplied to each individual before
        calculating its fitness.

        Args:
            arguments (dict[str, type]): A dictionary mapping argument
                names to their corresponding type.
        """
        for name, type_ in arguments.items():
            if type_ not in self._terminal:
                self._terminal[type_] = []
            self._terminal[type_].append(GPTerminal(
                rtype=type_,
                name=name,
            ))

    def add_terminals(self, terminals: list[Any]) -> None:
        """Add terminal symbols to the list of alleles in this pool.

        Args:
            arguments (list[Any]): A list of terminal symbols.
        """
        for value in terminals:
            var = GPTerminal(
                rtype=type(value),
                name="",
                value=value,
            )
            if type(value) not in self._terminal:
                self._terminal[type(value)] = []
            self._terminal[type(value)].append(var)
