from abc import ABC, abstractmethod
from enum import Enum, auto
from typing import Callable, Optional, Union

import numpy as np


class GeneType(Enum):
    """Enum class for a category of a gene type.
    Availalbe types are:

        * ``NOMINAL``
        * ``ORDINAL``
        * ``METRIC``
        * ``CONST_SIZE``

    This way, non-comparable types in Python are forbidden.
    """

    NOMINAL = auto()
    ORDINAL = auto()
    METRIC = auto()


class GenePool(ABC):
    """Base class for any gene pool in PEAL. A gene pool is a collection
    of alleles for genes an individual can have. With this information,
    a gene pool knows all possible genomes individuals in a population
    for a given problem can have.

    Args:
        typing (GeneType): The typing signature for this gene pool.
        length (int, optional): The length of one genome or ``0`` for
            variable length. Defaults to 0.
    """

    def __init__(self, typing: GeneType, length: int = 0):
        self._size = 0 if typing != GeneType.METRIC else np.inf
        self._typing = typing
        self._initializer: Optional[Callable[[], np.ndarray]] = None
        self._length = length

    @property
    def typing(self) -> GeneType:
        """The typing information of this gene pool."""
        return self._typing

    @property
    def size(self) -> Union[int, float]:
        """The number of different alleles in this gene pool. This might
        also be ``numpy.inf`` for metric scales.
        """
        return self._size

    @property
    def length(self) -> int:
        """The number of genes in one genome generated by this pool.
        If the size of one genome has variable length, this property is
        ``0``.
        """
        return self._length

    @abstractmethod
    def _initialize(self, **kwargs) -> np.ndarray:
        ...

    def initializer(
        self,
        func: Callable[[], np.ndarray],
    ) -> Callable[[], np.ndarray]:
        """Decorator for a non-standard initializer method. Use it on a
        function that takes no arguments and returns a numpy array which
        represents a genome of this gene pool.
        """
        self._initializer = func
        return func

    def create_genome(self, **kwargs) -> np.ndarray:
        """Generates a genome for an individual. The method used to pick
        a random genome can be customized.

        Returns:
            np.ndarray: An array consisting of genes.
        """
        if self._initializer is not None:
            return self._initializer(**kwargs)
        return self._initialize(**kwargs)


class BitPool(GenePool):
    """A gene pool of constant length genomes only containing zeros and
    ones.

    Args:
        length (int): The number of genes in a genome.
    """

    def __init__(
        self,
        length: int,
    ) -> None:
        super().__init__(typing=GeneType.NOMINAL, length=length)
        self._size = 2

    def _initialize(self, **kwargs) -> np.ndarray:
        return np.random.choice([True, False], size=self.length)


class IntegerPool(GenePool):
    """A gene pool of constant length genomes only containing integers
    in the given range.

    Args:
        length (int): The number of genes in a genome.
        lower (int): The smallest integer one gene can be.
        upper (int): The largest integer one gene can be.
    """

    def __init__(
        self,
        length: int,
        lower: int,
        upper: int,
    ) -> None:
        super().__init__(typing=GeneType.ORDINAL, length=length)
        self.lower = lower
        self.upper = upper
        self._size = upper - lower + 1

    def _initialize(self, **kwargs) -> np.ndarray:
        return np.random.randint(
            self.lower,
            self.upper + 1,
            size=self.length
        )


class NumberPool(GenePool):
    """A gene pool that supports all floats and integers in a specified
    range.

    Args:
        length (int): The number of genes in a genome.
        lower (int | float): The lower bound for all genes.
        upper (int | float): The upper bound for all genes.
    """

    def __init__(
        self,
        length: int,
        lower: Union[int, float],
        upper: Union[int, float],
    ) -> None:
        super().__init__(typing=GeneType.METRIC, length=length)
        self.lower = lower
        self.upper = upper

    def _initialize(self, **kwargs) -> np.ndarray:
        return (
            (self.upper - self.lower)
            * np.random.random_sample(size=self.length)
            + self.lower
        )
